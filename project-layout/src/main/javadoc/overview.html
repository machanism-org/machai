<!-- 
@guidance:
**IMPORTANT: GENERATE CONTENT FOR THIS FILE: `overview.html` ACCORDING TO THE BEST PRACTICES AND RULES BELOW.**

Use information from `pom.xml` for get information about PROJECT_NAME: `project.name`, PROJECT_DESCRIPTION: `project.description`.
[PROJECT_NAME] supports all types of project filesâ€”including source code, documentation, project site content, and other relevant files.

- **Write Clear and Concise Descriptions:**
    - Follow best practices for creating a package overview.
    - Provide meaningful summaries that clearly explain the purpose, behavior, and usage of each element.
    - Avoid vague or generic statements; be specific about functionality and intent.
    - Aggregate information from `package-info.java` files from source folders.
    - Use the class diagram located at `../images/class-diagram.png`.
    - Create a detailed package-level overview that describes its overall purpose, structure, and usage.

- **Automatic Fixes for Javadoc Build Issues:**
    - If Javadoc build fails due to invalid @throws tags or missing required Javadoc, 
       automatically correct these issues in the generated `overview.html` content (e.g., omit invalid tags, add missing descriptions as needed).
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project Layout - Overview</title>
</head>
<body>

<h1>Project Layout</h1>

<p>
  Project Layout is a small utility library for describing and working with conventional project directory layouts
  (sources, resources, tests, docs, etc.) in a consistent way. It is intended for build tooling and plugins that need
  to locate well-known folders reliably across different projects.
</p>

<h2>Scope and concepts</h2>

<p>
  A <em>project layout</em> describes how a repository is organized on disk: where production sources and tests live,
  where resources and documentation are located, and how to discover nested modules (sub-projects) when a build system
  defines them.
</p>

<p>
  This library models those conventions as root-relative paths associated with a project root directory. Consumers can
  resolve the returned strings against the project root to access the filesystem.
</p>

<h2>Packages and responsibilities</h2>

<h3><code>org.machanism.machai.project</code></h3>

<p>
  Facilities for discovering, describing, and processing a source-code project rooted at a filesystem directory.
  The primary entry point is
  {@code org.machanism.machai.project.ProjectLayoutManager#detectProjectLayout(java.io.File)}, which selects an
  appropriate {@code org.machanism.machai.project.layout.ProjectLayout} implementation for a given directory.
</p>

<p>
  For repository-wide traversal, extend {@code org.machanism.machai.project.ProjectProcessor}. The processor scans a
  root directory and recurses into module roots as reported by the selected layout.
</p>

<h3><code>org.machanism.machai.project.layout</code></h3>

<p>
  Abstractions and implementations for build-ecosystem-specific conventions. The central type is
  {@code org.machanism.machai.project.layout.ProjectLayout}, which exposes conventional directories for sources, tests,
  resources, documentation, and optional module directories.
</p>

<p>
  Implementations may consult build metadata (for example Maven {@code pom.xml}, Gradle settings, JavaScript
  {@code package.json} workspaces, or Python {@code pyproject.toml}) and may also use filesystem scanning. Most layout
  scanners exclude common build/VCS/IDE directories; see {@code ProjectLayout#EXCLUDE_DIRS}.
</p>

<h2>Typical workflow</h2>

<ol>
  <li>Pick or detect a {@code ProjectLayout} for a project root directory.</li>
  <li>Query the layout for conventional directories (returned as root-relative paths).</li>
  <li>Optionally traverse a repository and process each discovered project/module via a {@code ProjectProcessor}.</li>
</ol>

<h2>Examples</h2>

<h3>Detect a layout and access conventional folders</h3>

<pre><code>java.io.File projectDir = new java.io.File("C:\\path\\to\\project");

org.machanism.machai.project.layout.ProjectLayout layout =
    org.machanism.machai.project.ProjectLayoutManager.detectProjectLayout(projectDir);

java.util.List&lt;String&gt; sources = layout.getSources();
java.util.List&lt;String&gt; tests = layout.getTests();
java.util.List&lt;String&gt; documents = layout.getDocuments();
java.util.List&lt;String&gt; modules = layout.getModules();

// Resolve root-relative paths against the project directory before filesystem access.
for (String rel : sources) {
  java.io.File dir = new java.io.File(projectDir, rel);
  // ...
}</code></pre>

<h3>Scan a repository tree with a processor</h3>

<pre><code>java.io.File repoDir = new java.io.File("C:\\path\\to\\repo");

org.machanism.machai.project.ProjectProcessor processor = /* your implementation */ null;
processor.scanFolder(repoDir);

// The per-project hook is invoked for the root and for each discovered module.</code></pre>

<h2>Class diagram</h2>

<p>
  The diagram below summarizes the primary abstractions and their relationships.
</p>

<p>
  <img src="../images/class-diagram.png" alt="Project Layout - class diagram" />
</p>

<h2>Notes</h2>

<ul>
  <li>
    Some layouts infer modules from build metadata (for example Maven modules from {@code pom.xml}); others use
    filesystem scanning as a fallback.
  </li>
  <li>
    Layout detectors typically ignore common build, VCS, IDE, and environment directories. Refer to
    {@code org.machanism.machai.project.layout.ProjectLayout#EXCLUDE_DIRS}.
  </li>
</ul>

</body>
</html>
